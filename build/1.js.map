{"version":3,"sources":["webpack:///./src/client/components/LazyLoad/poly.js","webpack:///./src/client/components/LazyLoad/observer.js"],"names":["window","document","IntersectionObserverEntry","prototype","Object","defineProperty","get","intersectionRatio","registry","entry","time","target","rootBounds","boundingClientRect","intersectionRect","getEmptyRect","isIntersecting","targetRect","targetArea","width","height","intersectionArea","IntersectionObserver","callback","opt_options","options","Error","root","nodeType","_checkForIntersections","throttle","bind","THROTTLE_TIMEOUT","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","rootMargin","thresholds","_initThresholds","threshold","map","margin","value","unit","join","POLL_INTERVAL","observe","some","item","element","_registerInstance","push","_monitorIntersections","unobserve","filter","length","_unmonitorIntersections","_unregisterInstance","disconnect","takeRecords","records","slice","opt_threshold","Array","isArray","sort","t","i","a","isNaN","opt_rootMargin","marginString","margins","split","parts","exec","parseFloat","_monitoringIntersections","_monitoringInterval","setInterval","addEvent","_domObserver","MutationObserver","attributes","childList","characterData","subtree","clearInterval","removeEvent","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","forEach","getBoundingClientRect","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","now","_hasCrossedThreshold","getComputedStyle","display","parent","getParentNode","atRoot","parentRect","parentComputedStyle","body","documentElement","overflow","computeRectIntersection","html","top","left","right","clientWidth","bottom","clientHeight","_expandRectByRootMargin","rect","newRect","oldRatio","newRatio","containsDeep","indexOf","index","splice","performance","fn","timeout","timer","setTimeout","node","event","opt_useCapture","addEventListener","attachEvent","removeEventListener","detatchEvent","rect1","rect2","Math","max","min","el","err","child","parentNode","host","loadImage","src","resolve","reject","img","Image","intersectionCb","entries","observer","dataset","then"],"mappings":";;;;;;;;;;AAAA;;;;;;;;;;;;;;;;AAgBC,WAASA,MAAT,EAAiBC,QAAjB,EAA2B;AACxB;;AAGA;AACA;;AACA,MAAI,0BAA0BD,MAA1B,IACA,+BAA+BA,MAD/B,IAEA,uBAAuBA,OAAOE,yBAAP,CAAiCC,SAF5D,EAEuE;;AAErE;AACA;AACA,QAAI,EAAE,oBAAoBH,OAAOE,yBAAP,CAAiCC,SAAvD,CAAJ,EAAuE;AACrEC,aAAOC,cAAP,CAAsBL,OAAOE,yBAAP,CAAiCC,SAAvD,EACE,gBADF,EACoB;AAClBG,aAAK,eAAY;AACf,iBAAO,KAAKC,iBAAL,GAAyB,CAAhC;AACD;AAHiB,OADpB;AAMD;AACD;AACD;;AAGD;;;;;;AAMA,MAAIC,WAAW,EAAf;;AAGA;;;;;;AAMA,WAASN,yBAAT,CAAmCO,KAAnC,EAA0C;AACxC,SAAKC,IAAL,GAAYD,MAAMC,IAAlB;AACA,SAAKC,MAAL,GAAcF,MAAME,MAApB;AACA,SAAKC,UAAL,GAAkBH,MAAMG,UAAxB;AACA,SAAKC,kBAAL,GAA0BJ,MAAMI,kBAAhC;AACA,SAAKC,gBAAL,GAAwBL,MAAMK,gBAAN,IAA0BC,cAAlD;AACA,SAAKC,cAAL,GAAsB,CAAC,CAACP,MAAMK,gBAA9B;;AAEA;AACA,QAAIG,aAAa,KAAKJ,kBAAtB;AACA,QAAIK,aAAaD,WAAWE,KAAX,GAAmBF,WAAWG,MAA/C;AACA,QAAIN,mBAAmB,KAAKA,gBAA5B;AACA,QAAIO,mBAAmBP,iBAAiBK,KAAjB,GAAyBL,iBAAiBM,MAAjE;;AAEA;AACA,QAAIF,UAAJ,EAAgB;AACd,WAAKX,iBAAL,GAAyBc,mBAAmBH,UAA5C;AACD,KAFD,MAEO;AACL;AACA,WAAKX,iBAAL,GAAyB,KAAKS,cAAL,GAAsB,CAAtB,GAA0B,CAAnD;AACD;AACF;;AAGD;;;;;;;;;AASA,WAASM,oBAAT,CAA8BC,QAA9B,EAAwCC,WAAxC,EAAqD;;AAEnD,QAAIC,UAAUD,eAAe,EAA7B;;AAEA,QAAI,OAAOD,QAAP,IAAmB,UAAvB,EAAmC;AACjC,YAAM,IAAIG,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,QAAID,QAAQE,IAAR,IAAgBF,QAAQE,IAAR,CAAaC,QAAb,IAAyB,CAA7C,EAAgD;AAC9C,YAAM,IAAIF,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED;AACA,SAAKG,sBAAL,GAA8BC,SAC1B,KAAKD,sBAAL,CAA4BE,IAA5B,CAAiC,IAAjC,CAD0B,EACc,KAAKC,gBADnB,CAA9B;;AAGA;AACA,SAAKC,SAAL,GAAiBV,QAAjB;AACA,SAAKW,mBAAL,GAA2B,EAA3B;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,iBAAL,GAAyB,KAAKC,gBAAL,CAAsBZ,QAAQa,UAA9B,CAAzB;;AAEA;AACA,SAAKC,UAAL,GAAkB,KAAKC,eAAL,CAAqBf,QAAQgB,SAA7B,CAAlB;AACA,SAAKd,IAAL,GAAYF,QAAQE,IAAR,IAAgB,IAA5B;AACA,SAAKW,UAAL,GAAkB,KAAKF,iBAAL,CAAuBM,GAAvB,CAA2B,UAASC,MAAT,EAAiB;AAC5D,aAAOA,OAAOC,KAAP,GAAeD,OAAOE,IAA7B;AACD,KAFiB,EAEfC,IAFe,CAEV,GAFU,CAAlB;AAGD;;AAGD;;;;AAIAxB,uBAAqBnB,SAArB,CAA+B6B,gBAA/B,GAAkD,GAAlD;;AAGA;;;;;AAKAV,uBAAqBnB,SAArB,CAA+B4C,aAA/B,GAA+C,IAA/C;;AAGA;;;;;AAKAzB,uBAAqBnB,SAArB,CAA+B6C,OAA/B,GAAyC,UAASrC,MAAT,EAAiB;AACxD;AACA,QAAI,KAAKuB,mBAAL,CAAyBe,IAAzB,CAA8B,UAASC,IAAT,EAAe;AAC/C,aAAOA,KAAKC,OAAL,IAAgBxC,MAAvB;AACD,KAFG,CAAJ,EAEI;AACF;AACD;;AAED,QAAI,EAAEA,UAAUA,OAAOiB,QAAP,IAAmB,CAA/B,CAAJ,EAAuC;AACrC,YAAM,IAAIF,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,SAAK0B,iBAAL;AACA,SAAKlB,mBAAL,CAAyBmB,IAAzB,CAA8B,EAACF,SAASxC,MAAV,EAAkBF,OAAO,IAAzB,EAA9B;AACA,SAAK6C,qBAAL;AACA,SAAKzB,sBAAL;AACD,GAhBD;;AAmBA;;;;AAIAP,uBAAqBnB,SAArB,CAA+BoD,SAA/B,GAA2C,UAAS5C,MAAT,EAAiB;AAC1D,SAAKuB,mBAAL,GACI,KAAKA,mBAAL,CAAyBsB,MAAzB,CAAgC,UAASN,IAAT,EAAe;;AAEjD,aAAOA,KAAKC,OAAL,IAAgBxC,MAAvB;AACD,KAHG,CADJ;AAKA,QAAI,CAAC,KAAKuB,mBAAL,CAAyBuB,MAA9B,EAAsC;AACpC,WAAKC,uBAAL;AACA,WAAKC,mBAAL;AACD;AACF,GAVD;;AAaA;;;AAGArC,uBAAqBnB,SAArB,CAA+ByD,UAA/B,GAA4C,YAAW;AACrD,SAAK1B,mBAAL,GAA2B,EAA3B;AACA,SAAKwB,uBAAL;AACA,SAAKC,mBAAL;AACD,GAJD;;AAOA;;;;;;AAMArC,uBAAqBnB,SAArB,CAA+B0D,WAA/B,GAA6C,YAAW;AACtD,QAAIC,UAAU,KAAK3B,cAAL,CAAoB4B,KAApB,EAAd;AACA,SAAK5B,cAAL,GAAsB,EAAtB;AACA,WAAO2B,OAAP;AACD,GAJD;;AAOA;;;;;;;;;AASAxC,uBAAqBnB,SAArB,CAA+BqC,eAA/B,GAAiD,UAASwB,aAAT,EAAwB;AACvE,QAAIvB,YAAYuB,iBAAiB,CAAC,CAAD,CAAjC;AACA,QAAI,CAACC,MAAMC,OAAN,CAAczB,SAAd,CAAL,EAA+BA,YAAY,CAACA,SAAD,CAAZ;;AAE/B,WAAOA,UAAU0B,IAAV,GAAiBX,MAAjB,CAAwB,UAASY,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB;AAC/C,UAAI,OAAOF,CAAP,IAAY,QAAZ,IAAwBG,MAAMH,CAAN,CAAxB,IAAoCA,IAAI,CAAxC,IAA6CA,IAAI,CAArD,EAAwD;AACtD,cAAM,IAAI1C,KAAJ,CAAU,wDAAV,CAAN;AACD;AACD,aAAO0C,MAAME,EAAED,IAAI,CAAN,CAAb;AACD,KALM,CAAP;AAMD,GAVD;;AAaA;;;;;;;;;;;AAWA/C,uBAAqBnB,SAArB,CAA+BkC,gBAA/B,GAAkD,UAASmC,cAAT,EAAyB;AACzE,QAAIC,eAAeD,kBAAkB,KAArC;AACA,QAAIE,UAAUD,aAAaE,KAAb,CAAmB,KAAnB,EAA0BjC,GAA1B,CAA8B,UAASC,MAAT,EAAiB;AAC3D,UAAIiC,QAAQ,wBAAwBC,IAAxB,CAA6BlC,MAA7B,CAAZ;AACA,UAAI,CAACiC,KAAL,EAAY;AACV,cAAM,IAAIlD,KAAJ,CAAU,mDAAV,CAAN;AACD;AACD,aAAO,EAACkB,OAAOkC,WAAWF,MAAM,CAAN,CAAX,CAAR,EAA8B/B,MAAM+B,MAAM,CAAN,CAApC,EAAP;AACD,KANa,CAAd;;AAQA;AACAF,YAAQ,CAAR,IAAaA,QAAQ,CAAR,KAAcA,QAAQ,CAAR,CAA3B;AACAA,YAAQ,CAAR,IAAaA,QAAQ,CAAR,KAAcA,QAAQ,CAAR,CAA3B;AACAA,YAAQ,CAAR,IAAaA,QAAQ,CAAR,KAAcA,QAAQ,CAAR,CAA3B;;AAEA,WAAOA,OAAP;AACD,GAhBD;;AAmBA;;;;;AAKApD,uBAAqBnB,SAArB,CAA+BmD,qBAA/B,GAAuD,YAAW;AAChE,QAAI,CAAC,KAAKyB,wBAAV,EAAoC;AAClC,WAAKA,wBAAL,GAAgC,IAAhC;;AAEA;AACA;AACA,UAAI,KAAKhC,aAAT,EAAwB;AACtB,aAAKiC,mBAAL,GAA2BC,YACvB,KAAKpD,sBADkB,EACM,KAAKkB,aADX,CAA3B;AAED,OAHD,MAIK;AACHmC,iBAASlF,MAAT,EAAiB,QAAjB,EAA2B,KAAK6B,sBAAhC,EAAwD,IAAxD;AACAqD,iBAASjF,QAAT,EAAmB,QAAnB,EAA6B,KAAK4B,sBAAlC,EAA0D,IAA1D;;AAEA,YAAI,sBAAsB7B,MAA1B,EAAkC;AAChC,eAAKmF,YAAL,GAAoB,IAAIC,gBAAJ,CAAqB,KAAKvD,sBAA1B,CAApB;AACA,eAAKsD,YAAL,CAAkBnC,OAAlB,CAA0B/C,QAA1B,EAAoC;AAClCoF,wBAAY,IADsB;AAElCC,uBAAW,IAFuB;AAGlCC,2BAAe,IAHmB;AAIlCC,qBAAS;AAJyB,WAApC;AAMD;AACF;AACF;AACF,GAzBD;;AA4BA;;;;AAIAlE,uBAAqBnB,SAArB,CAA+BuD,uBAA/B,GAAyD,YAAW;AAClE,QAAI,KAAKqB,wBAAT,EAAmC;AACjC,WAAKA,wBAAL,GAAgC,KAAhC;;AAEAU,oBAAc,KAAKT,mBAAnB;AACA,WAAKA,mBAAL,GAA2B,IAA3B;;AAEAU,kBAAY1F,MAAZ,EAAoB,QAApB,EAA8B,KAAK6B,sBAAnC,EAA2D,IAA3D;AACA6D,kBAAYzF,QAAZ,EAAsB,QAAtB,EAAgC,KAAK4B,sBAArC,EAA6D,IAA7D;;AAEA,UAAI,KAAKsD,YAAT,EAAuB;AACrB,aAAKA,YAAL,CAAkBvB,UAAlB;AACA,aAAKuB,YAAL,GAAoB,IAApB;AACD;AACF;AACF,GAfD;;AAkBA;;;;;;AAMA7D,uBAAqBnB,SAArB,CAA+B0B,sBAA/B,GAAwD,YAAW;AACjE,QAAI8D,cAAc,KAAKC,YAAL,EAAlB;AACA,QAAIC,WAAWF,cAAc,KAAKG,YAAL,EAAd,GAAoC/E,cAAnD;;AAEA,SAAKmB,mBAAL,CAAyB6D,OAAzB,CAAiC,UAAS7C,IAAT,EAAe;AAC9C,UAAIvC,SAASuC,KAAKC,OAAlB;AACA,UAAIlC,aAAa+E,sBAAsBrF,MAAtB,CAAjB;AACA,UAAIsF,qBAAqB,KAAKC,mBAAL,CAAyBvF,MAAzB,CAAzB;AACA,UAAIwF,WAAWjD,KAAKzC,KAApB;AACA,UAAIK,mBAAmB6E,eAAeM,kBAAf,IACnB,KAAKG,iCAAL,CAAuCzF,MAAvC,EAA+CkF,QAA/C,CADJ;;AAGA,UAAIQ,WAAWnD,KAAKzC,KAAL,GAAa,IAAIP,yBAAJ,CAA8B;AACxDQ,cAAM4F,KADkD;AAExD3F,gBAAQA,MAFgD;AAGxDE,4BAAoBI,UAHoC;AAIxDL,oBAAYiF,QAJ4C;AAKxD/E,0BAAkBA;AALsC,OAA9B,CAA5B;;AAQA,UAAI,CAACqF,QAAL,EAAe;AACb,aAAKhE,cAAL,CAAoBkB,IAApB,CAAyBgD,QAAzB;AACD,OAFD,MAEO,IAAIV,eAAeM,kBAAnB,EAAuC;AAC5C;AACA;AACA,YAAI,KAAKM,oBAAL,CAA0BJ,QAA1B,EAAoCE,QAApC,CAAJ,EAAmD;AACjD,eAAKlE,cAAL,CAAoBkB,IAApB,CAAyBgD,QAAzB;AACD;AACF,OANM,MAMA;AACL;AACA;AACA;AACA,YAAIF,YAAYA,SAASnF,cAAzB,EAAyC;AACvC,eAAKmB,cAAL,CAAoBkB,IAApB,CAAyBgD,QAAzB;AACD;AACF;AACF,KAhCD,EAgCG,IAhCH;;AAkCA,QAAI,KAAKlE,cAAL,CAAoBsB,MAAxB,EAAgC;AAC9B,WAAKxB,SAAL,CAAe,KAAK4B,WAAL,EAAf,EAAmC,IAAnC;AACD;AACF,GAzCD;;AA4CA;;;;;;;;;;;;AAYAvC,uBAAqBnB,SAArB,CAA+BiG,iCAA/B,GACI,UAASzF,MAAT,EAAiBkF,QAAjB,EAA2B;;AAE7B;AACA,QAAI7F,OAAOwG,gBAAP,CAAwB7F,MAAxB,EAAgC8F,OAAhC,IAA2C,MAA/C,EAAuD;;AAEvD,QAAIxF,aAAa+E,sBAAsBrF,MAAtB,CAAjB;AACA,QAAIG,mBAAmBG,UAAvB;AACA,QAAIyF,SAASC,cAAchG,MAAd,CAAb;AACA,QAAIiG,SAAS,KAAb;;AAEA,WAAO,CAACA,MAAR,EAAgB;AACd,UAAIC,aAAa,IAAjB;AACA,UAAIC,sBAAsBJ,OAAO9E,QAAP,IAAmB,CAAnB,GACtB5B,OAAOwG,gBAAP,CAAwBE,MAAxB,CADsB,GACY,EADtC;;AAGA;AACA,UAAII,oBAAoBL,OAApB,IAA+B,MAAnC,EAA2C;;AAE3C,UAAIC,UAAU,KAAK/E,IAAf,IAAuB+E,UAAUzG,QAArC,EAA+C;AAC7C2G,iBAAS,IAAT;AACAC,qBAAahB,QAAb;AACD,OAHD,MAGO;AACL;AACA;AACA;AACA;AACA,YAAIa,UAAUzG,SAAS8G,IAAnB,IACAL,UAAUzG,SAAS+G,eADnB,IAEAF,oBAAoBG,QAApB,IAAgC,SAFpC,EAE+C;AAC7CJ,uBAAab,sBAAsBU,MAAtB,CAAb;AACD;AACF;;AAED;AACA;AACA,UAAIG,UAAJ,EAAgB;AACd/F,2BAAmBoG,wBAAwBL,UAAxB,EAAoC/F,gBAApC,CAAnB;;AAEA,YAAI,CAACA,gBAAL,EAAuB;AACxB;AACD4F,eAASC,cAAcD,MAAd,CAAT;AACD;AACD,WAAO5F,gBAAP;AACD,GA5CD;;AA+CA;;;;;AAKAQ,uBAAqBnB,SAArB,CAA+B2F,YAA/B,GAA8C,YAAW;AACvD,QAAID,QAAJ;AACA,QAAI,KAAKlE,IAAT,EAAe;AACbkE,iBAAWG,sBAAsB,KAAKrE,IAA3B,CAAX;AACD,KAFD,MAEO;AACL;AACA,UAAIwF,OAAOlH,SAAS+G,eAApB;AACA,UAAID,OAAO9G,SAAS8G,IAApB;AACAlB,iBAAW;AACTuB,aAAK,CADI;AAETC,cAAM,CAFG;AAGTC,eAAOH,KAAKI,WAAL,IAAoBR,KAAKQ,WAHvB;AAITpG,eAAOgG,KAAKI,WAAL,IAAoBR,KAAKQ,WAJvB;AAKTC,gBAAQL,KAAKM,YAAL,IAAqBV,KAAKU,YALzB;AAMTrG,gBAAQ+F,KAAKM,YAAL,IAAqBV,KAAKU;AANzB,OAAX;AAQD;AACD,WAAO,KAAKC,uBAAL,CAA6B7B,QAA7B,CAAP;AACD,GAlBD;;AAqBA;;;;;;AAMAvE,uBAAqBnB,SAArB,CAA+BuH,uBAA/B,GAAyD,UAASC,IAAT,EAAe;AACtE,QAAIjD,UAAU,KAAKtC,iBAAL,CAAuBM,GAAvB,CAA2B,UAASC,MAAT,EAAiB0B,CAAjB,EAAoB;AAC3D,aAAO1B,OAAOE,IAAP,IAAe,IAAf,GAAsBF,OAAOC,KAA7B,GACHD,OAAOC,KAAP,IAAgByB,IAAI,CAAJ,GAAQsD,KAAKxG,KAAb,GAAqBwG,KAAKvG,MAA1C,IAAoD,GADxD;AAED,KAHa,CAAd;AAIA,QAAIwG,UAAU;AACZR,WAAKO,KAAKP,GAAL,GAAW1C,QAAQ,CAAR,CADJ;AAEZ4C,aAAOK,KAAKL,KAAL,GAAa5C,QAAQ,CAAR,CAFR;AAGZ8C,cAAQG,KAAKH,MAAL,GAAc9C,QAAQ,CAAR,CAHV;AAIZ2C,YAAMM,KAAKN,IAAL,GAAY3C,QAAQ,CAAR;AAJN,KAAd;AAMAkD,YAAQzG,KAAR,GAAgByG,QAAQN,KAAR,GAAgBM,QAAQP,IAAxC;AACAO,YAAQxG,MAAR,GAAiBwG,QAAQJ,MAAR,GAAiBI,QAAQR,GAA1C;;AAEA,WAAOQ,OAAP;AACD,GAfD;;AAkBA;;;;;;;;;;AAUAtG,uBAAqBnB,SAArB,CAA+BoG,oBAA/B,GACI,UAASJ,QAAT,EAAmBE,QAAnB,EAA6B;;AAE/B;AACA;AACA,QAAIwB,WAAW1B,YAAYA,SAASnF,cAArB,GACXmF,SAAS5F,iBAAT,IAA8B,CADnB,GACuB,CAAC,CADvC;AAEA,QAAIuH,WAAWzB,SAASrF,cAAT,GACXqF,SAAS9F,iBAAT,IAA8B,CADnB,GACuB,CAAC,CADvC;;AAGA;AACA,QAAIsH,aAAaC,QAAjB,EAA2B;;AAE3B,SAAK,IAAIzD,IAAI,CAAb,EAAgBA,IAAI,KAAK9B,UAAL,CAAgBkB,MAApC,EAA4CY,GAA5C,EAAiD;AAC/C,UAAI5B,YAAY,KAAKF,UAAL,CAAgB8B,CAAhB,CAAhB;;AAEA;AACA;AACA,UAAI5B,aAAaoF,QAAb,IAAyBpF,aAAaqF,QAAtC,IACArF,YAAYoF,QAAZ,KAAyBpF,YAAYqF,QADzC,EACmD;AACjD,eAAO,IAAP;AACD;AACF;AACF,GAvBD;;AA0BA;;;;;AAKAxG,uBAAqBnB,SAArB,CAA+ByF,YAA/B,GAA8C,YAAW;AACvD,WAAO,CAAC,KAAKjE,IAAN,IAAcoG,aAAa9H,QAAb,EAAuB,KAAK0B,IAA5B,CAArB;AACD,GAFD;;AAKA;;;;;;AAMAL,uBAAqBnB,SAArB,CAA+B+F,mBAA/B,GAAqD,UAASvF,MAAT,EAAiB;AACpE,WAAOoH,aAAa,KAAKpG,IAAL,IAAa1B,QAA1B,EAAoCU,MAApC,CAAP;AACD,GAFD;;AAKA;;;;;AAKAW,uBAAqBnB,SAArB,CAA+BiD,iBAA/B,GAAmD,YAAW;AAC5D,QAAI5C,SAASwH,OAAT,CAAiB,IAAjB,IAAyB,CAA7B,EAAgC;AAC9BxH,eAAS6C,IAAT,CAAc,IAAd;AACD;AACF,GAJD;;AAOA;;;;AAIA/B,uBAAqBnB,SAArB,CAA+BwD,mBAA/B,GAAqD,YAAW;AAC9D,QAAIsE,QAAQzH,SAASwH,OAAT,CAAiB,IAAjB,CAAZ;AACA,QAAIC,SAAS,CAAC,CAAd,EAAiBzH,SAAS0H,MAAT,CAAgBD,KAAhB,EAAuB,CAAvB;AAClB,GAHD;;AAMA;;;;;AAKA,WAAS3B,GAAT,GAAe;AACb,WAAOtG,OAAOmI,WAAP,IAAsBA,YAAY7B,GAAlC,IAAyC6B,YAAY7B,GAAZ,EAAhD;AACD;;AAGD;;;;;;;;AAQA,WAASxE,QAAT,CAAkBsG,EAAlB,EAAsBC,OAAtB,EAA+B;AAC7B,QAAIC,QAAQ,IAAZ;AACA,WAAO,YAAY;AACjB,UAAI,CAACA,KAAL,EAAY;AACVA,gBAAQC,WAAW,YAAW;AAC5BH;AACAE,kBAAQ,IAAR;AACD,SAHO,EAGLD,OAHK,CAAR;AAID;AACF,KAPD;AAQD;;AAGD;;;;;;;;AAQA,WAASnD,QAAT,CAAkBsD,IAAlB,EAAwBC,KAAxB,EAA+BL,EAA/B,EAAmCM,cAAnC,EAAmD;AACjD,QAAI,OAAOF,KAAKG,gBAAZ,IAAgC,UAApC,EAAgD;AAC9CH,WAAKG,gBAAL,CAAsBF,KAAtB,EAA6BL,EAA7B,EAAiCM,kBAAkB,KAAnD;AACD,KAFD,MAGK,IAAI,OAAOF,KAAKI,WAAZ,IAA2B,UAA/B,EAA2C;AAC9CJ,WAAKI,WAAL,CAAiB,OAAOH,KAAxB,EAA+BL,EAA/B;AACD;AACF;;AAGD;;;;;;;;AAQA,WAAS1C,WAAT,CAAqB8C,IAArB,EAA2BC,KAA3B,EAAkCL,EAAlC,EAAsCM,cAAtC,EAAsD;AACpD,QAAI,OAAOF,KAAKK,mBAAZ,IAAmC,UAAvC,EAAmD;AACjDL,WAAKK,mBAAL,CAAyBJ,KAAzB,EAAgCL,EAAhC,EAAoCM,kBAAkB,KAAtD;AACD,KAFD,MAGK,IAAI,OAAOF,KAAKM,YAAZ,IAA4B,UAAhC,EAA4C;AAC/CN,WAAKM,YAAL,CAAkB,OAAOL,KAAzB,EAAgCL,EAAhC;AACD;AACF;;AAGD;;;;;;;AAOA,WAASlB,uBAAT,CAAiC6B,KAAjC,EAAwCC,KAAxC,EAA+C;AAC7C,QAAI5B,MAAM6B,KAAKC,GAAL,CAASH,MAAM3B,GAAf,EAAoB4B,MAAM5B,GAA1B,CAAV;AACA,QAAII,SAASyB,KAAKE,GAAL,CAASJ,MAAMvB,MAAf,EAAuBwB,MAAMxB,MAA7B,CAAb;AACA,QAAIH,OAAO4B,KAAKC,GAAL,CAASH,MAAM1B,IAAf,EAAqB2B,MAAM3B,IAA3B,CAAX;AACA,QAAIC,QAAQ2B,KAAKE,GAAL,CAASJ,MAAMzB,KAAf,EAAsB0B,MAAM1B,KAA5B,CAAZ;AACA,QAAInG,QAAQmG,QAAQD,IAApB;AACA,QAAIjG,SAASoG,SAASJ,GAAtB;;AAEA,WAAQjG,SAAS,CAAT,IAAcC,UAAU,CAAzB,IAA+B;AACpCgG,WAAKA,GAD+B;AAEpCI,cAAQA,MAF4B;AAGpCH,YAAMA,IAH8B;AAIpCC,aAAOA,KAJ6B;AAKpCnG,aAAOA,KAL6B;AAMpCC,cAAQA;AAN4B,KAAtC;AAQD;;AAGD;;;;;AAKA,WAAS4E,qBAAT,CAA+BoD,EAA/B,EAAmC;AACjC,QAAIzB,IAAJ;;AAEA,QAAI;AACFA,aAAOyB,GAAGpD,qBAAH,EAAP;AACD,KAFD,CAEE,OAAOqD,GAAP,EAAY;AACZ;AACA;AACD;;AAED,QAAI,CAAC1B,IAAL,EAAW,OAAO5G,cAAP;;AAEX;AACA,QAAI,EAAE4G,KAAKxG,KAAL,IAAcwG,KAAKvG,MAArB,CAAJ,EAAkC;AAChCuG,aAAO;AACLP,aAAKO,KAAKP,GADL;AAELE,eAAOK,KAAKL,KAFP;AAGLE,gBAAQG,KAAKH,MAHR;AAILH,cAAMM,KAAKN,IAJN;AAKLlG,eAAOwG,KAAKL,KAAL,GAAaK,KAAKN,IALpB;AAMLjG,gBAAQuG,KAAKH,MAAL,GAAcG,KAAKP;AANtB,OAAP;AAQD;AACD,WAAOO,IAAP;AACD;;AAGD;;;;;AAKA,WAAS5G,YAAT,GAAwB;AACtB,WAAO;AACLqG,WAAK,CADA;AAELI,cAAQ,CAFH;AAGLH,YAAM,CAHD;AAILC,aAAO,CAJF;AAKLnG,aAAO,CALF;AAMLC,cAAQ;AANH,KAAP;AAQD;;AAED;;;;;;;AAOA,WAAS2G,YAAT,CAAsBrB,MAAtB,EAA8B4C,KAA9B,EAAqC;AACnC,QAAId,OAAOc,KAAX;AACA,WAAOd,IAAP,EAAa;AACX,UAAIA,QAAQ9B,MAAZ,EAAoB,OAAO,IAAP;;AAEpB8B,aAAO7B,cAAc6B,IAAd,CAAP;AACD;AACD,WAAO,KAAP;AACD;;AAGD;;;;;;AAMA,WAAS7B,aAAT,CAAuB6B,IAAvB,EAA6B;AAC3B,QAAI9B,SAAS8B,KAAKe,UAAlB;;AAEA,QAAI7C,UAAUA,OAAO9E,QAAP,IAAmB,EAA7B,IAAmC8E,OAAO8C,IAA9C,EAAoD;AAClD;AACA,aAAO9C,OAAO8C,IAAd;AACD;AACD,WAAO9C,MAAP;AACD;;AAGD;AACA1G,SAAOsB,oBAAP,GAA8BA,oBAA9B;AACAtB,SAAOE,yBAAP,GAAmCA,yBAAnC;AAEC,CAnsBJ,EAmsBKF,MAnsBL,EAmsBaC,QAnsBb,CAAD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;;;;AAEA,IAAMwB,UAAU;AACdE,QAAM,IADQ;AAEdW,cAAY,UAFE;AAGdG,aAAW;AAHG,CAAhB;;AAMA,SAASgH,SAAT,CAAmBC,GAAnB,EAAwB;AACtB,SAAO,sBAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAMC,MAAM,IAAIC,KAAJ,EAAZ;AACAD,QAAIlB,gBAAJ,CAAqB,MAArB,EAA6BgB,OAA7B;AACAE,QAAIlB,gBAAJ,CAAqB,OAArB,EAA8BiB,MAA9B;AACAC,QAAIH,GAAJ,GAAUA,GAAV;AACD,GALM,CAAP;AAMD;;AAED,SAASK,cAAT,CAAwBC,OAAxB,EAAiCC,QAAjC,EAA2C;AACzC,MAAI5F,IAAI2F,QAAQvG,MAAhB;;AADyC;AAGvC,QAAMhD,QAAQuJ,QAAQ3F,CAAR,CAAd;AACA,QAAMmE,OAAO/H,MAAME,MAAnB;AACA,QAAIF,MAAMF,iBAAN,GAA0B,CAA9B,EAAiC;AAC/B0J,eAAS1G,SAAT,CAAmB9C,MAAME,MAAzB;AACA8I,gBAAUjB,KAAK0B,OAAL,CAAaR,GAAvB,EAA4BS,IAA5B,CAAiC,YAAM;AACrC3B,aAAKkB,GAAL,GAAWlB,KAAK0B,OAAL,CAAaR,GAAxB;AACD,OAFD;AAGD;AAVsC;;AAEzC,SAAOrF,GAAP,GAAa;AAAA;AASZ;AACF;;AAEM,IAAM4F,8BAAW,IAAI3I,oBAAJ,CAAyByI,cAAzB,EAAyCtI,OAAzC,CAAjB;;AAEP,SAASuB,OAAT,CAAiBwF,IAAjB,EAAuB;AACrByB,WAASjH,OAAT,CAAiBwF,IAAjB;AACD;;eAEcxF,O;;;;;;;;;gCA7BNyG,S;;gCASAM,c;;gCAcIE,Q;;gCAEJjH,O;;gCA/BHvB,O","file":"1.js","sourcesContent":["/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function(window, document) {\n    'use strict';\n\n\n    // Exits early if all IntersectionObserver and IntersectionObserverEntry\n    // features are natively supported.\n    if ('IntersectionObserver' in window &&\n        'IntersectionObserverEntry' in window &&\n        'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\n      // Minimal polyfill for Edge 15's lack of `isIntersecting`\n      // See: https://github.com/w3c/IntersectionObserver/issues/211\n      if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n        Object.defineProperty(window.IntersectionObserverEntry.prototype,\n          'isIntersecting', {\n          get: function () {\n            return this.intersectionRatio > 0;\n          }\n        });\n      }\n      return;\n    }\n\n\n    /**\n     * An IntersectionObserver registry. This registry exists to hold a strong\n     * reference to IntersectionObserver instances currently observering a target\n     * element. Without this registry, instances without another reference may be\n     * garbage collected.\n     */\n    var registry = [];\n\n\n    /**\n     * Creates the global IntersectionObserverEntry constructor.\n     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n     * @param {Object} entry A dictionary of instance properties.\n     * @constructor\n     */\n    function IntersectionObserverEntry(entry) {\n      this.time = entry.time;\n      this.target = entry.target;\n      this.rootBounds = entry.rootBounds;\n      this.boundingClientRect = entry.boundingClientRect;\n      this.intersectionRect = entry.intersectionRect || getEmptyRect();\n      this.isIntersecting = !!entry.intersectionRect;\n\n      // Calculates the intersection ratio.\n      var targetRect = this.boundingClientRect;\n      var targetArea = targetRect.width * targetRect.height;\n      var intersectionRect = this.intersectionRect;\n      var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n      // Sets intersection ratio.\n      if (targetArea) {\n        this.intersectionRatio = intersectionArea / targetArea;\n      } else {\n        // If area is zero and is intersecting, sets to 1, otherwise to 0\n        this.intersectionRatio = this.isIntersecting ? 1 : 0;\n      }\n    }\n\n\n    /**\n     * Creates the global IntersectionObserver constructor.\n     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n     * @param {Function} callback The function to be invoked after intersection\n     *     changes have queued. The function is not invoked if the queue has\n     *     been emptied by calling the `takeRecords` method.\n     * @param {Object=} opt_options Optional configuration options.\n     * @constructor\n     */\n    function IntersectionObserver(callback, opt_options) {\n\n      var options = opt_options || {};\n\n      if (typeof callback != 'function') {\n        throw new Error('callback must be a function');\n      }\n\n      if (options.root && options.root.nodeType != 1) {\n        throw new Error('root must be an Element');\n      }\n\n      // Binds and throttles `this._checkForIntersections`.\n      this._checkForIntersections = throttle(\n          this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n      // Private properties.\n      this._callback = callback;\n      this._observationTargets = [];\n      this._queuedEntries = [];\n      this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n      // Public properties.\n      this.thresholds = this._initThresholds(options.threshold);\n      this.root = options.root || null;\n      this.rootMargin = this._rootMarginValues.map(function(margin) {\n        return margin.value + margin.unit;\n      }).join(' ');\n    }\n\n\n    /**\n     * The minimum interval within which the document will be checked for\n     * intersection changes.\n     */\n    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n    /**\n     * The frequency in which the polyfill polls for intersection changes.\n     * this can be updated on a per instance basis and must be set prior to\n     * calling `observe` on the first target.\n     */\n    IntersectionObserver.prototype.POLL_INTERVAL = null;\n\n\n    /**\n     * Starts observing a target element for intersection changes based on\n     * the thresholds values.\n     * @param {Element} target The DOM element to observe.\n     */\n    IntersectionObserver.prototype.observe = function(target) {\n      // If the target is already being observed, do nothing.\n      if (this._observationTargets.some(function(item) {\n        return item.element == target;\n      })) {\n        return;\n      }\n\n      if (!(target && target.nodeType == 1)) {\n        throw new Error('target must be an Element');\n      }\n\n      this._registerInstance();\n      this._observationTargets.push({element: target, entry: null});\n      this._monitorIntersections();\n      this._checkForIntersections();\n    };\n\n\n    /**\n     * Stops observing a target element for intersection changes.\n     * @param {Element} target The DOM element to observe.\n     */\n    IntersectionObserver.prototype.unobserve = function(target) {\n      this._observationTargets =\n          this._observationTargets.filter(function(item) {\n\n        return item.element != target;\n      });\n      if (!this._observationTargets.length) {\n        this._unmonitorIntersections();\n        this._unregisterInstance();\n      }\n    };\n\n\n    /**\n     * Stops observing all target elements for intersection changes.\n     */\n    IntersectionObserver.prototype.disconnect = function() {\n      this._observationTargets = [];\n      this._unmonitorIntersections();\n      this._unregisterInstance();\n    };\n\n\n    /**\n     * Returns any queue entries that have not yet been reported to the\n     * callback and clears the queue. This can be used in conjunction with the\n     * callback to obtain the absolute most up-to-date intersection information.\n     * @return {Array} The currently queued entries.\n     */\n    IntersectionObserver.prototype.takeRecords = function() {\n      var records = this._queuedEntries.slice();\n      this._queuedEntries = [];\n      return records;\n    };\n\n\n    /**\n     * Accepts the threshold value from the user configuration object and\n     * returns a sorted array of unique threshold values. If a value is not\n     * between 0 and 1 and error is thrown.\n     * @private\n     * @param {Array|number=} opt_threshold An optional threshold value or\n     *     a list of threshold values, defaulting to [0].\n     * @return {Array} A sorted list of unique and valid threshold values.\n     */\n    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n      var threshold = opt_threshold || [0];\n      if (!Array.isArray(threshold)) threshold = [threshold];\n\n      return threshold.sort().filter(function(t, i, a) {\n        if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n          throw new Error('threshold must be a number between 0 and 1 inclusively');\n        }\n        return t !== a[i - 1];\n      });\n    };\n\n\n    /**\n     * Accepts the rootMargin value from the user configuration object\n     * and returns an array of the four margin values as an object containing\n     * the value and unit properties. If any of the values are not properly\n     * formatted or use a unit other than px or %, and error is thrown.\n     * @private\n     * @param {string=} opt_rootMargin An optional rootMargin value,\n     *     defaulting to '0px'.\n     * @return {Array<Object>} An array of margin objects with the keys\n     *     value and unit.\n     */\n    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n      var marginString = opt_rootMargin || '0px';\n      var margins = marginString.split(/\\s+/).map(function(margin) {\n        var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n        if (!parts) {\n          throw new Error('rootMargin must be specified in pixels or percent');\n        }\n        return {value: parseFloat(parts[1]), unit: parts[2]};\n      });\n\n      // Handles shorthand.\n      margins[1] = margins[1] || margins[0];\n      margins[2] = margins[2] || margins[0];\n      margins[3] = margins[3] || margins[1];\n\n      return margins;\n    };\n\n\n    /**\n     * Starts polling for intersection changes if the polling is not already\n     * happening, and if the page's visibilty state is visible.\n     * @private\n     */\n    IntersectionObserver.prototype._monitorIntersections = function() {\n      if (!this._monitoringIntersections) {\n        this._monitoringIntersections = true;\n\n        // If a poll interval is set, use polling instead of listening to\n        // resize and scroll events or DOM mutations.\n        if (this.POLL_INTERVAL) {\n          this._monitoringInterval = setInterval(\n              this._checkForIntersections, this.POLL_INTERVAL);\n        }\n        else {\n          addEvent(window, 'resize', this._checkForIntersections, true);\n          addEvent(document, 'scroll', this._checkForIntersections, true);\n\n          if ('MutationObserver' in window) {\n            this._domObserver = new MutationObserver(this._checkForIntersections);\n            this._domObserver.observe(document, {\n              attributes: true,\n              childList: true,\n              characterData: true,\n              subtree: true\n            });\n          }\n        }\n      }\n    };\n\n\n    /**\n     * Stops polling for intersection changes.\n     * @private\n     */\n    IntersectionObserver.prototype._unmonitorIntersections = function() {\n      if (this._monitoringIntersections) {\n        this._monitoringIntersections = false;\n\n        clearInterval(this._monitoringInterval);\n        this._monitoringInterval = null;\n\n        removeEvent(window, 'resize', this._checkForIntersections, true);\n        removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n        if (this._domObserver) {\n          this._domObserver.disconnect();\n          this._domObserver = null;\n        }\n      }\n    };\n\n\n    /**\n     * Scans each observation target for intersection changes and adds them\n     * to the internal entries queue. If new entries are found, it\n     * schedules the callback to be invoked.\n     * @private\n     */\n    IntersectionObserver.prototype._checkForIntersections = function() {\n      var rootIsInDom = this._rootIsInDom();\n      var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n      this._observationTargets.forEach(function(item) {\n        var target = item.element;\n        var targetRect = getBoundingClientRect(target);\n        var rootContainsTarget = this._rootContainsTarget(target);\n        var oldEntry = item.entry;\n        var intersectionRect = rootIsInDom && rootContainsTarget &&\n            this._computeTargetAndRootIntersection(target, rootRect);\n\n        var newEntry = item.entry = new IntersectionObserverEntry({\n          time: now(),\n          target: target,\n          boundingClientRect: targetRect,\n          rootBounds: rootRect,\n          intersectionRect: intersectionRect\n        });\n\n        if (!oldEntry) {\n          this._queuedEntries.push(newEntry);\n        } else if (rootIsInDom && rootContainsTarget) {\n          // If the new entry intersection ratio has crossed any of the\n          // thresholds, add a new entry.\n          if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n            this._queuedEntries.push(newEntry);\n          }\n        } else {\n          // If the root is not in the DOM or target is not contained within\n          // root but the previous entry for this target had an intersection,\n          // add a new record indicating removal.\n          if (oldEntry && oldEntry.isIntersecting) {\n            this._queuedEntries.push(newEntry);\n          }\n        }\n      }, this);\n\n      if (this._queuedEntries.length) {\n        this._callback(this.takeRecords(), this);\n      }\n    };\n\n\n    /**\n     * Accepts a target and root rect computes the intersection between then\n     * following the algorithm in the spec.\n     * TODO(philipwalton): at this time clip-path is not considered.\n     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n     * @param {Element} target The target DOM element\n     * @param {Object} rootRect The bounding rect of the root after being\n     *     expanded by the rootMargin value.\n     * @return {?Object} The final intersection rect object or undefined if no\n     *     intersection is found.\n     * @private\n     */\n    IntersectionObserver.prototype._computeTargetAndRootIntersection =\n        function(target, rootRect) {\n\n      // If the element isn't displayed, an intersection can't happen.\n      if (window.getComputedStyle(target).display == 'none') return;\n\n      var targetRect = getBoundingClientRect(target);\n      var intersectionRect = targetRect;\n      var parent = getParentNode(target);\n      var atRoot = false;\n\n      while (!atRoot) {\n        var parentRect = null;\n        var parentComputedStyle = parent.nodeType == 1 ?\n            window.getComputedStyle(parent) : {};\n\n        // If the parent isn't displayed, an intersection can't happen.\n        if (parentComputedStyle.display == 'none') return;\n\n        if (parent == this.root || parent == document) {\n          atRoot = true;\n          parentRect = rootRect;\n        } else {\n          // If the element has a non-visible overflow, and it's not the <body>\n          // or <html> element, update the intersection rect.\n          // Note: <body> and <html> cannot be clipped to a rect that's not also\n          // the document rect, so no need to compute a new intersection.\n          if (parent != document.body &&\n              parent != document.documentElement &&\n              parentComputedStyle.overflow != 'visible') {\n            parentRect = getBoundingClientRect(parent);\n          }\n        }\n\n        // If either of the above conditionals set a new parentRect,\n        // calculate new intersection data.\n        if (parentRect) {\n          intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n          if (!intersectionRect) break;\n        }\n        parent = getParentNode(parent);\n      }\n      return intersectionRect;\n    };\n\n\n    /**\n     * Returns the root rect after being expanded by the rootMargin value.\n     * @return {Object} The expanded root rect.\n     * @private\n     */\n    IntersectionObserver.prototype._getRootRect = function() {\n      var rootRect;\n      if (this.root) {\n        rootRect = getBoundingClientRect(this.root);\n      } else {\n        // Use <html>/<body> instead of window since scroll bars affect size.\n        var html = document.documentElement;\n        var body = document.body;\n        rootRect = {\n          top: 0,\n          left: 0,\n          right: html.clientWidth || body.clientWidth,\n          width: html.clientWidth || body.clientWidth,\n          bottom: html.clientHeight || body.clientHeight,\n          height: html.clientHeight || body.clientHeight\n        };\n      }\n      return this._expandRectByRootMargin(rootRect);\n    };\n\n\n    /**\n     * Accepts a rect and expands it by the rootMargin value.\n     * @param {Object} rect The rect object to expand.\n     * @return {Object} The expanded rect.\n     * @private\n     */\n    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n      var margins = this._rootMarginValues.map(function(margin, i) {\n        return margin.unit == 'px' ? margin.value :\n            margin.value * (i % 2 ? rect.width : rect.height) / 100;\n      });\n      var newRect = {\n        top: rect.top - margins[0],\n        right: rect.right + margins[1],\n        bottom: rect.bottom + margins[2],\n        left: rect.left - margins[3]\n      };\n      newRect.width = newRect.right - newRect.left;\n      newRect.height = newRect.bottom - newRect.top;\n\n      return newRect;\n    };\n\n\n    /**\n     * Accepts an old and new entry and returns true if at least one of the\n     * threshold values has been crossed.\n     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n     *    particular target element or null if no previous entry exists.\n     * @param {IntersectionObserverEntry} newEntry The current entry for a\n     *    particular target element.\n     * @return {boolean} Returns true if a any threshold has been crossed.\n     * @private\n     */\n    IntersectionObserver.prototype._hasCrossedThreshold =\n        function(oldEntry, newEntry) {\n\n      // To make comparing easier, an entry that has a ratio of 0\n      // but does not actually intersect is given a value of -1\n      var oldRatio = oldEntry && oldEntry.isIntersecting ?\n          oldEntry.intersectionRatio || 0 : -1;\n      var newRatio = newEntry.isIntersecting ?\n          newEntry.intersectionRatio || 0 : -1;\n\n      // Ignore unchanged ratios\n      if (oldRatio === newRatio) return;\n\n      for (var i = 0; i < this.thresholds.length; i++) {\n        var threshold = this.thresholds[i];\n\n        // Return true if an entry matches a threshold or if the new ratio\n        // and the old ratio are on the opposite sides of a threshold.\n        if (threshold == oldRatio || threshold == newRatio ||\n            threshold < oldRatio !== threshold < newRatio) {\n          return true;\n        }\n      }\n    };\n\n\n    /**\n     * Returns whether or not the root element is an element and is in the DOM.\n     * @return {boolean} True if the root element is an element and is in the DOM.\n     * @private\n     */\n    IntersectionObserver.prototype._rootIsInDom = function() {\n      return !this.root || containsDeep(document, this.root);\n    };\n\n\n    /**\n     * Returns whether or not the target element is a child of root.\n     * @param {Element} target The target element to check.\n     * @return {boolean} True if the target element is a child of root.\n     * @private\n     */\n    IntersectionObserver.prototype._rootContainsTarget = function(target) {\n      return containsDeep(this.root || document, target);\n    };\n\n\n    /**\n     * Adds the instance to the global IntersectionObserver registry if it isn't\n     * already present.\n     * @private\n     */\n    IntersectionObserver.prototype._registerInstance = function() {\n      if (registry.indexOf(this) < 0) {\n        registry.push(this);\n      }\n    };\n\n\n    /**\n     * Removes the instance from the global IntersectionObserver registry.\n     * @private\n     */\n    IntersectionObserver.prototype._unregisterInstance = function() {\n      var index = registry.indexOf(this);\n      if (index != -1) registry.splice(index, 1);\n    };\n\n\n    /**\n     * Returns the result of the performance.now() method or null in browsers\n     * that don't support the API.\n     * @return {number} The elapsed time since the page was requested.\n     */\n    function now() {\n      return window.performance && performance.now && performance.now();\n    }\n\n\n    /**\n     * Throttles a function and delays its executiong, so it's only called at most\n     * once within a given time period.\n     * @param {Function} fn The function to throttle.\n     * @param {number} timeout The amount of time that must pass before the\n     *     function can be called again.\n     * @return {Function} The throttled function.\n     */\n    function throttle(fn, timeout) {\n      var timer = null;\n      return function () {\n        if (!timer) {\n          timer = setTimeout(function() {\n            fn();\n            timer = null;\n          }, timeout);\n        }\n      };\n    }\n\n\n    /**\n     * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n     * @param {Node} node The DOM node to add the event handler to.\n     * @param {string} event The event name.\n     * @param {Function} fn The event handler to add.\n     * @param {boolean} opt_useCapture Optionally adds the even to the capture\n     *     phase. Note: this only works in modern browsers.\n     */\n    function addEvent(node, event, fn, opt_useCapture) {\n      if (typeof node.addEventListener == 'function') {\n        node.addEventListener(event, fn, opt_useCapture || false);\n      }\n      else if (typeof node.attachEvent == 'function') {\n        node.attachEvent('on' + event, fn);\n      }\n    }\n\n\n    /**\n     * Removes a previously added event handler from a DOM node.\n     * @param {Node} node The DOM node to remove the event handler from.\n     * @param {string} event The event name.\n     * @param {Function} fn The event handler to remove.\n     * @param {boolean} opt_useCapture If the event handler was added with this\n     *     flag set to true, it should be set to true here in order to remove it.\n     */\n    function removeEvent(node, event, fn, opt_useCapture) {\n      if (typeof node.removeEventListener == 'function') {\n        node.removeEventListener(event, fn, opt_useCapture || false);\n      }\n      else if (typeof node.detatchEvent == 'function') {\n        node.detatchEvent('on' + event, fn);\n      }\n    }\n\n\n    /**\n     * Returns the intersection between two rect objects.\n     * @param {Object} rect1 The first rect.\n     * @param {Object} rect2 The second rect.\n     * @return {?Object} The intersection rect or undefined if no intersection\n     *     is found.\n     */\n    function computeRectIntersection(rect1, rect2) {\n      var top = Math.max(rect1.top, rect2.top);\n      var bottom = Math.min(rect1.bottom, rect2.bottom);\n      var left = Math.max(rect1.left, rect2.left);\n      var right = Math.min(rect1.right, rect2.right);\n      var width = right - left;\n      var height = bottom - top;\n\n      return (width >= 0 && height >= 0) && {\n        top: top,\n        bottom: bottom,\n        left: left,\n        right: right,\n        width: width,\n        height: height\n      };\n    }\n\n\n    /**\n     * Shims the native getBoundingClientRect for compatibility with older IE.\n     * @param {Element} el The element whose bounding rect to get.\n     * @return {Object} The (possibly shimmed) rect of the element.\n     */\n    function getBoundingClientRect(el) {\n      var rect;\n\n      try {\n        rect = el.getBoundingClientRect();\n      } catch (err) {\n        // Ignore Windows 7 IE11 \"Unspecified error\"\n        // https://github.com/w3c/IntersectionObserver/pull/205\n      }\n\n      if (!rect) return getEmptyRect();\n\n      // Older IE\n      if (!(rect.width && rect.height)) {\n        rect = {\n          top: rect.top,\n          right: rect.right,\n          bottom: rect.bottom,\n          left: rect.left,\n          width: rect.right - rect.left,\n          height: rect.bottom - rect.top\n        };\n      }\n      return rect;\n    }\n\n\n    /**\n     * Returns an empty rect object. An empty rect is returned when an element\n     * is not in the DOM.\n     * @return {Object} The empty rect.\n     */\n    function getEmptyRect() {\n      return {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    /**\n     * Checks to see if a parent element contains a child elemnt (including inside\n     * shadow DOM).\n     * @param {Node} parent The parent element.\n     * @param {Node} child The child element.\n     * @return {boolean} True if the parent node contains the child node.\n     */\n    function containsDeep(parent, child) {\n      var node = child;\n      while (node) {\n        if (node == parent) return true;\n\n        node = getParentNode(node);\n      }\n      return false;\n    }\n\n\n    /**\n     * Gets the parent node of an element or its host element if the parent node\n     * is a shadow root.\n     * @param {Node} node The node whose parent to get.\n     * @return {Node|null} The parent node or null if no parent exists.\n     */\n    function getParentNode(node) {\n      var parent = node.parentNode;\n\n      if (parent && parent.nodeType == 11 && parent.host) {\n        // If the parent is a shadow root, return the host element.\n        return parent.host;\n      }\n      return parent;\n    }\n\n\n    // Exposes the constructors globally.\n    window.IntersectionObserver = IntersectionObserver;\n    window.IntersectionObserverEntry = IntersectionObserverEntry;\n\n    }(window, document));\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/components/LazyLoad/poly.js","import './poly';\n\nconst options = {\n  root: null,\n  rootMargin: '50px 0px',\n  threshold: 0.01,\n};\n\nfunction loadImage(src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.addEventListener('load', resolve);\n    img.addEventListener('error', reject);\n    img.src = src;\n  });\n}\n\nfunction intersectionCb(entries, observer) {\n  let i = entries.length;\n  for (; i--;) {\n    const entry = entries[i];\n    const node = entry.target;\n    if (entry.intersectionRatio > 0) {\n      observer.unobserve(entry.target);\n      loadImage(node.dataset.src).then(() => {\n        node.src = node.dataset.src;\n      });\n    }\n  }\n}\n\nexport const observer = new IntersectionObserver(intersectionCb, options);\n\nfunction observe(node) {\n  observer.observe(node);\n}\n\nexport default observe;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/components/LazyLoad/observer.js"],"sourceRoot":""}