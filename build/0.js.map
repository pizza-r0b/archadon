{"version":3,"sources":["webpack:///./src/client/components/LazyLoad/observer.js","webpack:///./src/client/components/LazyLoad/poly.js"],"names":["options","root","rootMargin","threshold","loadImage","src","resolve","reject","img","Image","addEventListener","intersectionCb","entries","observer","i","length","entry","node","target","intersectionRatio","unobserve","dataset","then","catch","IntersectionObserver","observe","window","document","IntersectionObserverEntry","prototype","Object","defineProperty","get","registry","time","rootBounds","boundingClientRect","intersectionRect","getEmptyRect","isIntersecting","targetRect","targetArea","width","height","intersectionArea","callback","opt_options","Error","nodeType","_checkForIntersections","throttle","bind","THROTTLE_TIMEOUT","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","thresholds","_initThresholds","map","margin","value","unit","join","POLL_INTERVAL","some","item","element","_registerInstance","push","_monitorIntersections","filter","_unmonitorIntersections","_unregisterInstance","disconnect","takeRecords","records","slice","opt_threshold","Array","isArray","sort","t","a","isNaN","opt_rootMargin","marginString","margins","split","parts","exec","parseFloat","_monitoringIntersections","_monitoringInterval","setInterval","addEvent","_domObserver","MutationObserver","attributes","childList","characterData","subtree","clearInterval","removeEvent","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","forEach","getBoundingClientRect","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","now","_hasCrossedThreshold","getComputedStyle","display","parent","getParentNode","atRoot","parentRect","parentComputedStyle","body","documentElement","overflow","computeRectIntersection","html","top","left","right","clientWidth","bottom","clientHeight","_expandRectByRootMargin","rect","newRect","oldRatio","newRatio","containsDeep","indexOf","index","splice","performance","fn","timeout","timer","setTimeout","event","opt_useCapture","attachEvent","removeEventListener","detatchEvent","rect1","rect2","Math","max","min","el","err","child","parentNode","host"],"mappings":"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","file":"0.js","sourcesContent":["import './poly';\n\nconst options = {\n  root: null,\n  rootMargin: '50px 0px',\n  threshold: 0.01,\n};\n\nfunction loadImage(src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.addEventListener('load', resolve);\n    img.addEventListener('error', reject);\n    img.src = src;\n  });\n}\n\nfunction intersectionCb(entries, observer) {\n  let i = entries.length;\n  for (; i--;) {\n    const entry = entries[i];\n    const node = entry.target;\n    if (entry.intersectionRatio > 0) {\n      observer.unobserve(entry.target);\n      loadImage(node.dataset.src).then(() => {\n        node.src = node.dataset.src;\n      }).catch(() => {\n        // noop\n      });\n    }\n  }\n}\n\nexport const observer = new IntersectionObserver(intersectionCb, options);\n\nfunction observe(node) {\n  observer.observe(node);\n}\n\nexport default observe;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/components/LazyLoad/observer.js","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function(window, document) {\n    'use strict';\n\n\n    // Exits early if all IntersectionObserver and IntersectionObserverEntry\n    // features are natively supported.\n    if ('IntersectionObserver' in window &&\n        'IntersectionObserverEntry' in window &&\n        'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\n      // Minimal polyfill for Edge 15's lack of `isIntersecting`\n      // See: https://github.com/w3c/IntersectionObserver/issues/211\n      if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n        Object.defineProperty(window.IntersectionObserverEntry.prototype,\n          'isIntersecting', {\n          get: function () {\n            return this.intersectionRatio > 0;\n          }\n        });\n      }\n      return;\n    }\n\n\n    /**\n     * An IntersectionObserver registry. This registry exists to hold a strong\n     * reference to IntersectionObserver instances currently observering a target\n     * element. Without this registry, instances without another reference may be\n     * garbage collected.\n     */\n    var registry = [];\n\n\n    /**\n     * Creates the global IntersectionObserverEntry constructor.\n     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n     * @param {Object} entry A dictionary of instance properties.\n     * @constructor\n     */\n    function IntersectionObserverEntry(entry) {\n      this.time = entry.time;\n      this.target = entry.target;\n      this.rootBounds = entry.rootBounds;\n      this.boundingClientRect = entry.boundingClientRect;\n      this.intersectionRect = entry.intersectionRect || getEmptyRect();\n      this.isIntersecting = !!entry.intersectionRect;\n\n      // Calculates the intersection ratio.\n      var targetRect = this.boundingClientRect;\n      var targetArea = targetRect.width * targetRect.height;\n      var intersectionRect = this.intersectionRect;\n      var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n      // Sets intersection ratio.\n      if (targetArea) {\n        this.intersectionRatio = intersectionArea / targetArea;\n      } else {\n        // If area is zero and is intersecting, sets to 1, otherwise to 0\n        this.intersectionRatio = this.isIntersecting ? 1 : 0;\n      }\n    }\n\n\n    /**\n     * Creates the global IntersectionObserver constructor.\n     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n     * @param {Function} callback The function to be invoked after intersection\n     *     changes have queued. The function is not invoked if the queue has\n     *     been emptied by calling the `takeRecords` method.\n     * @param {Object=} opt_options Optional configuration options.\n     * @constructor\n     */\n    function IntersectionObserver(callback, opt_options) {\n\n      var options = opt_options || {};\n\n      if (typeof callback != 'function') {\n        throw new Error('callback must be a function');\n      }\n\n      if (options.root && options.root.nodeType != 1) {\n        throw new Error('root must be an Element');\n      }\n\n      // Binds and throttles `this._checkForIntersections`.\n      this._checkForIntersections = throttle(\n          this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n      // Private properties.\n      this._callback = callback;\n      this._observationTargets = [];\n      this._queuedEntries = [];\n      this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n      // Public properties.\n      this.thresholds = this._initThresholds(options.threshold);\n      this.root = options.root || null;\n      this.rootMargin = this._rootMarginValues.map(function(margin) {\n        return margin.value + margin.unit;\n      }).join(' ');\n    }\n\n\n    /**\n     * The minimum interval within which the document will be checked for\n     * intersection changes.\n     */\n    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n    /**\n     * The frequency in which the polyfill polls for intersection changes.\n     * this can be updated on a per instance basis and must be set prior to\n     * calling `observe` on the first target.\n     */\n    IntersectionObserver.prototype.POLL_INTERVAL = null;\n\n\n    /**\n     * Starts observing a target element for intersection changes based on\n     * the thresholds values.\n     * @param {Element} target The DOM element to observe.\n     */\n    IntersectionObserver.prototype.observe = function(target) {\n      // If the target is already being observed, do nothing.\n      if (this._observationTargets.some(function(item) {\n        return item.element == target;\n      })) {\n        return;\n      }\n\n      if (!(target && target.nodeType == 1)) {\n        throw new Error('target must be an Element');\n      }\n\n      this._registerInstance();\n      this._observationTargets.push({element: target, entry: null});\n      this._monitorIntersections();\n      this._checkForIntersections();\n    };\n\n\n    /**\n     * Stops observing a target element for intersection changes.\n     * @param {Element} target The DOM element to observe.\n     */\n    IntersectionObserver.prototype.unobserve = function(target) {\n      this._observationTargets =\n          this._observationTargets.filter(function(item) {\n\n        return item.element != target;\n      });\n      if (!this._observationTargets.length) {\n        this._unmonitorIntersections();\n        this._unregisterInstance();\n      }\n    };\n\n\n    /**\n     * Stops observing all target elements for intersection changes.\n     */\n    IntersectionObserver.prototype.disconnect = function() {\n      this._observationTargets = [];\n      this._unmonitorIntersections();\n      this._unregisterInstance();\n    };\n\n\n    /**\n     * Returns any queue entries that have not yet been reported to the\n     * callback and clears the queue. This can be used in conjunction with the\n     * callback to obtain the absolute most up-to-date intersection information.\n     * @return {Array} The currently queued entries.\n     */\n    IntersectionObserver.prototype.takeRecords = function() {\n      var records = this._queuedEntries.slice();\n      this._queuedEntries = [];\n      return records;\n    };\n\n\n    /**\n     * Accepts the threshold value from the user configuration object and\n     * returns a sorted array of unique threshold values. If a value is not\n     * between 0 and 1 and error is thrown.\n     * @private\n     * @param {Array|number=} opt_threshold An optional threshold value or\n     *     a list of threshold values, defaulting to [0].\n     * @return {Array} A sorted list of unique and valid threshold values.\n     */\n    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n      var threshold = opt_threshold || [0];\n      if (!Array.isArray(threshold)) threshold = [threshold];\n\n      return threshold.sort().filter(function(t, i, a) {\n        if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n          throw new Error('threshold must be a number between 0 and 1 inclusively');\n        }\n        return t !== a[i - 1];\n      });\n    };\n\n\n    /**\n     * Accepts the rootMargin value from the user configuration object\n     * and returns an array of the four margin values as an object containing\n     * the value and unit properties. If any of the values are not properly\n     * formatted or use a unit other than px or %, and error is thrown.\n     * @private\n     * @param {string=} opt_rootMargin An optional rootMargin value,\n     *     defaulting to '0px'.\n     * @return {Array<Object>} An array of margin objects with the keys\n     *     value and unit.\n     */\n    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n      var marginString = opt_rootMargin || '0px';\n      var margins = marginString.split(/\\s+/).map(function(margin) {\n        var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n        if (!parts) {\n          throw new Error('rootMargin must be specified in pixels or percent');\n        }\n        return {value: parseFloat(parts[1]), unit: parts[2]};\n      });\n\n      // Handles shorthand.\n      margins[1] = margins[1] || margins[0];\n      margins[2] = margins[2] || margins[0];\n      margins[3] = margins[3] || margins[1];\n\n      return margins;\n    };\n\n\n    /**\n     * Starts polling for intersection changes if the polling is not already\n     * happening, and if the page's visibilty state is visible.\n     * @private\n     */\n    IntersectionObserver.prototype._monitorIntersections = function() {\n      if (!this._monitoringIntersections) {\n        this._monitoringIntersections = true;\n\n        // If a poll interval is set, use polling instead of listening to\n        // resize and scroll events or DOM mutations.\n        if (this.POLL_INTERVAL) {\n          this._monitoringInterval = setInterval(\n              this._checkForIntersections, this.POLL_INTERVAL);\n        }\n        else {\n          addEvent(window, 'resize', this._checkForIntersections, true);\n          addEvent(document, 'scroll', this._checkForIntersections, true);\n\n          if ('MutationObserver' in window) {\n            this._domObserver = new MutationObserver(this._checkForIntersections);\n            this._domObserver.observe(document, {\n              attributes: true,\n              childList: true,\n              characterData: true,\n              subtree: true\n            });\n          }\n        }\n      }\n    };\n\n\n    /**\n     * Stops polling for intersection changes.\n     * @private\n     */\n    IntersectionObserver.prototype._unmonitorIntersections = function() {\n      if (this._monitoringIntersections) {\n        this._monitoringIntersections = false;\n\n        clearInterval(this._monitoringInterval);\n        this._monitoringInterval = null;\n\n        removeEvent(window, 'resize', this._checkForIntersections, true);\n        removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n        if (this._domObserver) {\n          this._domObserver.disconnect();\n          this._domObserver = null;\n        }\n      }\n    };\n\n\n    /**\n     * Scans each observation target for intersection changes and adds them\n     * to the internal entries queue. If new entries are found, it\n     * schedules the callback to be invoked.\n     * @private\n     */\n    IntersectionObserver.prototype._checkForIntersections = function() {\n      var rootIsInDom = this._rootIsInDom();\n      var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n      this._observationTargets.forEach(function(item) {\n        var target = item.element;\n        var targetRect = getBoundingClientRect(target);\n        var rootContainsTarget = this._rootContainsTarget(target);\n        var oldEntry = item.entry;\n        var intersectionRect = rootIsInDom && rootContainsTarget &&\n            this._computeTargetAndRootIntersection(target, rootRect);\n\n        var newEntry = item.entry = new IntersectionObserverEntry({\n          time: now(),\n          target: target,\n          boundingClientRect: targetRect,\n          rootBounds: rootRect,\n          intersectionRect: intersectionRect\n        });\n\n        if (!oldEntry) {\n          this._queuedEntries.push(newEntry);\n        } else if (rootIsInDom && rootContainsTarget) {\n          // If the new entry intersection ratio has crossed any of the\n          // thresholds, add a new entry.\n          if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n            this._queuedEntries.push(newEntry);\n          }\n        } else {\n          // If the root is not in the DOM or target is not contained within\n          // root but the previous entry for this target had an intersection,\n          // add a new record indicating removal.\n          if (oldEntry && oldEntry.isIntersecting) {\n            this._queuedEntries.push(newEntry);\n          }\n        }\n      }, this);\n\n      if (this._queuedEntries.length) {\n        this._callback(this.takeRecords(), this);\n      }\n    };\n\n\n    /**\n     * Accepts a target and root rect computes the intersection between then\n     * following the algorithm in the spec.\n     * TODO(philipwalton): at this time clip-path is not considered.\n     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n     * @param {Element} target The target DOM element\n     * @param {Object} rootRect The bounding rect of the root after being\n     *     expanded by the rootMargin value.\n     * @return {?Object} The final intersection rect object or undefined if no\n     *     intersection is found.\n     * @private\n     */\n    IntersectionObserver.prototype._computeTargetAndRootIntersection =\n        function(target, rootRect) {\n\n      // If the element isn't displayed, an intersection can't happen.\n      if (window.getComputedStyle(target).display == 'none') return;\n\n      var targetRect = getBoundingClientRect(target);\n      var intersectionRect = targetRect;\n      var parent = getParentNode(target);\n      var atRoot = false;\n\n      while (!atRoot) {\n        var parentRect = null;\n        var parentComputedStyle = parent.nodeType == 1 ?\n            window.getComputedStyle(parent) : {};\n\n        // If the parent isn't displayed, an intersection can't happen.\n        if (parentComputedStyle.display == 'none') return;\n\n        if (parent == this.root || parent == document) {\n          atRoot = true;\n          parentRect = rootRect;\n        } else {\n          // If the element has a non-visible overflow, and it's not the <body>\n          // or <html> element, update the intersection rect.\n          // Note: <body> and <html> cannot be clipped to a rect that's not also\n          // the document rect, so no need to compute a new intersection.\n          if (parent != document.body &&\n              parent != document.documentElement &&\n              parentComputedStyle.overflow != 'visible') {\n            parentRect = getBoundingClientRect(parent);\n          }\n        }\n\n        // If either of the above conditionals set a new parentRect,\n        // calculate new intersection data.\n        if (parentRect) {\n          intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n          if (!intersectionRect) break;\n        }\n        parent = getParentNode(parent);\n      }\n      return intersectionRect;\n    };\n\n\n    /**\n     * Returns the root rect after being expanded by the rootMargin value.\n     * @return {Object} The expanded root rect.\n     * @private\n     */\n    IntersectionObserver.prototype._getRootRect = function() {\n      var rootRect;\n      if (this.root) {\n        rootRect = getBoundingClientRect(this.root);\n      } else {\n        // Use <html>/<body> instead of window since scroll bars affect size.\n        var html = document.documentElement;\n        var body = document.body;\n        rootRect = {\n          top: 0,\n          left: 0,\n          right: html.clientWidth || body.clientWidth,\n          width: html.clientWidth || body.clientWidth,\n          bottom: html.clientHeight || body.clientHeight,\n          height: html.clientHeight || body.clientHeight\n        };\n      }\n      return this._expandRectByRootMargin(rootRect);\n    };\n\n\n    /**\n     * Accepts a rect and expands it by the rootMargin value.\n     * @param {Object} rect The rect object to expand.\n     * @return {Object} The expanded rect.\n     * @private\n     */\n    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n      var margins = this._rootMarginValues.map(function(margin, i) {\n        return margin.unit == 'px' ? margin.value :\n            margin.value * (i % 2 ? rect.width : rect.height) / 100;\n      });\n      var newRect = {\n        top: rect.top - margins[0],\n        right: rect.right + margins[1],\n        bottom: rect.bottom + margins[2],\n        left: rect.left - margins[3]\n      };\n      newRect.width = newRect.right - newRect.left;\n      newRect.height = newRect.bottom - newRect.top;\n\n      return newRect;\n    };\n\n\n    /**\n     * Accepts an old and new entry and returns true if at least one of the\n     * threshold values has been crossed.\n     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n     *    particular target element or null if no previous entry exists.\n     * @param {IntersectionObserverEntry} newEntry The current entry for a\n     *    particular target element.\n     * @return {boolean} Returns true if a any threshold has been crossed.\n     * @private\n     */\n    IntersectionObserver.prototype._hasCrossedThreshold =\n        function(oldEntry, newEntry) {\n\n      // To make comparing easier, an entry that has a ratio of 0\n      // but does not actually intersect is given a value of -1\n      var oldRatio = oldEntry && oldEntry.isIntersecting ?\n          oldEntry.intersectionRatio || 0 : -1;\n      var newRatio = newEntry.isIntersecting ?\n          newEntry.intersectionRatio || 0 : -1;\n\n      // Ignore unchanged ratios\n      if (oldRatio === newRatio) return;\n\n      for (var i = 0; i < this.thresholds.length; i++) {\n        var threshold = this.thresholds[i];\n\n        // Return true if an entry matches a threshold or if the new ratio\n        // and the old ratio are on the opposite sides of a threshold.\n        if (threshold == oldRatio || threshold == newRatio ||\n            threshold < oldRatio !== threshold < newRatio) {\n          return true;\n        }\n      }\n    };\n\n\n    /**\n     * Returns whether or not the root element is an element and is in the DOM.\n     * @return {boolean} True if the root element is an element and is in the DOM.\n     * @private\n     */\n    IntersectionObserver.prototype._rootIsInDom = function() {\n      return !this.root || containsDeep(document, this.root);\n    };\n\n\n    /**\n     * Returns whether or not the target element is a child of root.\n     * @param {Element} target The target element to check.\n     * @return {boolean} True if the target element is a child of root.\n     * @private\n     */\n    IntersectionObserver.prototype._rootContainsTarget = function(target) {\n      return containsDeep(this.root || document, target);\n    };\n\n\n    /**\n     * Adds the instance to the global IntersectionObserver registry if it isn't\n     * already present.\n     * @private\n     */\n    IntersectionObserver.prototype._registerInstance = function() {\n      if (registry.indexOf(this) < 0) {\n        registry.push(this);\n      }\n    };\n\n\n    /**\n     * Removes the instance from the global IntersectionObserver registry.\n     * @private\n     */\n    IntersectionObserver.prototype._unregisterInstance = function() {\n      var index = registry.indexOf(this);\n      if (index != -1) registry.splice(index, 1);\n    };\n\n\n    /**\n     * Returns the result of the performance.now() method or null in browsers\n     * that don't support the API.\n     * @return {number} The elapsed time since the page was requested.\n     */\n    function now() {\n      return window.performance && performance.now && performance.now();\n    }\n\n\n    /**\n     * Throttles a function and delays its executiong, so it's only called at most\n     * once within a given time period.\n     * @param {Function} fn The function to throttle.\n     * @param {number} timeout The amount of time that must pass before the\n     *     function can be called again.\n     * @return {Function} The throttled function.\n     */\n    function throttle(fn, timeout) {\n      var timer = null;\n      return function () {\n        if (!timer) {\n          timer = setTimeout(function() {\n            fn();\n            timer = null;\n          }, timeout);\n        }\n      };\n    }\n\n\n    /**\n     * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n     * @param {Node} node The DOM node to add the event handler to.\n     * @param {string} event The event name.\n     * @param {Function} fn The event handler to add.\n     * @param {boolean} opt_useCapture Optionally adds the even to the capture\n     *     phase. Note: this only works in modern browsers.\n     */\n    function addEvent(node, event, fn, opt_useCapture) {\n      if (typeof node.addEventListener == 'function') {\n        node.addEventListener(event, fn, opt_useCapture || false);\n      }\n      else if (typeof node.attachEvent == 'function') {\n        node.attachEvent('on' + event, fn);\n      }\n    }\n\n\n    /**\n     * Removes a previously added event handler from a DOM node.\n     * @param {Node} node The DOM node to remove the event handler from.\n     * @param {string} event The event name.\n     * @param {Function} fn The event handler to remove.\n     * @param {boolean} opt_useCapture If the event handler was added with this\n     *     flag set to true, it should be set to true here in order to remove it.\n     */\n    function removeEvent(node, event, fn, opt_useCapture) {\n      if (typeof node.removeEventListener == 'function') {\n        node.removeEventListener(event, fn, opt_useCapture || false);\n      }\n      else if (typeof node.detatchEvent == 'function') {\n        node.detatchEvent('on' + event, fn);\n      }\n    }\n\n\n    /**\n     * Returns the intersection between two rect objects.\n     * @param {Object} rect1 The first rect.\n     * @param {Object} rect2 The second rect.\n     * @return {?Object} The intersection rect or undefined if no intersection\n     *     is found.\n     */\n    function computeRectIntersection(rect1, rect2) {\n      var top = Math.max(rect1.top, rect2.top);\n      var bottom = Math.min(rect1.bottom, rect2.bottom);\n      var left = Math.max(rect1.left, rect2.left);\n      var right = Math.min(rect1.right, rect2.right);\n      var width = right - left;\n      var height = bottom - top;\n\n      return (width >= 0 && height >= 0) && {\n        top: top,\n        bottom: bottom,\n        left: left,\n        right: right,\n        width: width,\n        height: height\n      };\n    }\n\n\n    /**\n     * Shims the native getBoundingClientRect for compatibility with older IE.\n     * @param {Element} el The element whose bounding rect to get.\n     * @return {Object} The (possibly shimmed) rect of the element.\n     */\n    function getBoundingClientRect(el) {\n      var rect;\n\n      try {\n        rect = el.getBoundingClientRect();\n      } catch (err) {\n        // Ignore Windows 7 IE11 \"Unspecified error\"\n        // https://github.com/w3c/IntersectionObserver/pull/205\n      }\n\n      if (!rect) return getEmptyRect();\n\n      // Older IE\n      if (!(rect.width && rect.height)) {\n        rect = {\n          top: rect.top,\n          right: rect.right,\n          bottom: rect.bottom,\n          left: rect.left,\n          width: rect.right - rect.left,\n          height: rect.bottom - rect.top\n        };\n      }\n      return rect;\n    }\n\n\n    /**\n     * Returns an empty rect object. An empty rect is returned when an element\n     * is not in the DOM.\n     * @return {Object} The empty rect.\n     */\n    function getEmptyRect() {\n      return {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    /**\n     * Checks to see if a parent element contains a child elemnt (including inside\n     * shadow DOM).\n     * @param {Node} parent The parent element.\n     * @param {Node} child The child element.\n     * @return {boolean} True if the parent node contains the child node.\n     */\n    function containsDeep(parent, child) {\n      var node = child;\n      while (node) {\n        if (node == parent) return true;\n\n        node = getParentNode(node);\n      }\n      return false;\n    }\n\n\n    /**\n     * Gets the parent node of an element or its host element if the parent node\n     * is a shadow root.\n     * @param {Node} node The node whose parent to get.\n     * @return {Node|null} The parent node or null if no parent exists.\n     */\n    function getParentNode(node) {\n      var parent = node.parentNode;\n\n      if (parent && parent.nodeType == 11 && parent.host) {\n        // If the parent is a shadow root, return the host element.\n        return parent.host;\n      }\n      return parent;\n    }\n\n\n    // Exposes the constructors globally.\n    window.IntersectionObserver = IntersectionObserver;\n    window.IntersectionObserverEntry = IntersectionObserverEntry;\n\n    }(window, document));\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/components/LazyLoad/poly.js"],"sourceRoot":""}